#this is the code for plotting different time delays: solar system Roemer delay, Dispersion measure and Period derivative.
#the code generates two plots: one shows individual delays, the other one shows the sum of all delays
# Solar system Roemer delay is the classical ligt travel time across earth orbit. It is the simple vaccum delay between the arrival of pulse at the obervatory and the solar system barycentric. To illustrate, imagine an Earth-Sun-Pulsar system, when earth is at the far orbit( of sun) relative to pulsar, the roemer delay will be the biggest and vice versa. The following plot starts at vernal equinox, where earth is the futherest from the pulsar, which creates the biggest delay. Later, as earth travels around the sun through autumn equinox and solstice points, the delay first gets smaller and then  bigger. (a continous cosine wave)
# Dispersion Measure delay is the delay due to dispersion in the interstella medium, so that the arrival time of pulse depends on the observing frequency. Here the oberserving frequency is set to be 600 Mhz and 800 Mhz. 
# Period Derivative is the pulsar spin down rate. As pulsar gets older and olders, it gradually slows down which will cause a time delay.
# a par file is needed to run this code. 
# the y-axis unit is in seconds


import sys
import matplotlib.pyplot as plt
import math
from pylab import *
from numpy import *


def Cel2Ecl( A, B ):
  betaa = math.asin( math.sin(math.radians(B) )*math.cos(math.radians(23.43) )-math.sin(math.radians(23.43) )*math.sin(math.radians(A))*math.cos(math.radians(B) ))
  lamdaa = math.acos( math.cos(math.radians(A) )*math.cos(math.radians(B))/math.cos(math.radians(betaa)))
  return (lamdaa,betaa)


f = open(sys.argv[1] , 'r' )
line = f.readlines()

#read in par file
for i in range(1,23 ):
  x = line[i].split(' ')
  y = []
  for j in range( len( x ) ):
    if x[j] <> '':
      y.append( x[j] )
  if i == 3:
    F0 = float( y[1] )
  elif i == 4:
    F1 = float( y[1] )
  elif i == 2:
    dec = y[1].split(':')
  elif i == 8:
    DM = float( y[1] )
  elif i == 20:
    M2 = float( y[1] )
    print "M2=",M2
  elif i == 1:
    ra = y[1].split(':')
  elif i == 7:
    TO = float( y[1] )
  elif i == 21:
    START = float( y[1] )
  elif i == 22:
    FINISH = float( y[1] )
    
    
rah = float( ra[0] )
ram = float( ra[1] )
ras = float( ra[2] )
deg = (rah) + (ram/60) + (ras/3600)

dech = float( dec[0] )
decm = float( dec[1] )
decs = float( dec[2] )
deg2 = (dech) + (decm/60) + (decs/3600)

lamdaa, betaa = Cel2Ecl( deg, deg2 )

f.close()

r = PB( M2  )

rah = float( ra[0] )
ram = float( ra[1] )
ras = float( ra[2] )
deg = (rah) + (ram/60) + (ras/3600)

dech = float( dec[0] )
decm = float( dec[1] )
decs = float( dec[2] )
deg2 = (dech) + (decm/60) + (decs/3600)

lamdaa, betaa = Cel2Ecl( deg, deg2 )

f.close()

t = arange(START, FINISH, 0.01)
s1 = 500 * 10**-22  * cos(betaa) * cos(( t  - TO  ) * 2 * pi  /365.25 + lamdaa) #here roemer has a much larger coefficient compare to the other two, so I reduce its value by 10^-22 to make them on the same scale
s2 = - F1 * ((t - TO) * 2 * pi /365.25)  /( F0**2)
s3 = 4.149 * 10**5 * DM * t/t * (600**-2 - 800**-2) * 0.001 * 10**-18 #DM delay is constant

figure(1)
plt.plot(t,s1,'g',label='solar system roemer delay*10^-22')
plt.plot(t,s2,'r',label='Period Derivative')
plt.plot(t,s3,'b',label='Dispersion Measure')

plt.legend(bbox_to_anchor=(0, 1), loc=2, borderaxespad=0.)

plt.xlabel('time')
plt.ylabel('model delay \n(seconds)')
plt.title('time delay model')

figure(2)
plt.plot(t,s1+s2-s3,'m',label='delay sum')

plt.legend(bbox_to_anchor=(0, 1), loc=2, borderaxespad=0.)

plt.xlabel('time')
plt.ylabel('model delay \n(seconds)')
plt.title('time delay model')
plt.show()
